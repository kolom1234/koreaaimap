<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>KoreaAiMap — 서울 도시데이터</title>
  <!-- Naver Maps JS (시각화 모듈 포함) -->
  <script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=i0l4aehusw&submodules=visualization"></script>
  <style>
    html,body,#map{height:100%;margin:0}
    #panel{position:absolute;top:12px;left:12px;background:#111a;backdrop-filter:blur(8px);
           color:#fff;padding:10px 12px;border-radius:12px;font:14px/1.4 system-ui}
    #panel input{width:130px}
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="panel">
    POI 코드:
    <input id="code" value="POI104"/>
    <button id="load">불러오기</button>
    <span id="updated" style="margin-left:6px;opacity:.8"></span>
  </div>

  <script>
  // 1) 지도 초기화(서울 시청 근처)
  const map = new naver.maps.Map('map', {
    center: new naver.maps.LatLng(37.5665,126.9780),
    zoom: 13, mapDataControl: true, logoControl: false, scaleControl: false
  });

  // 2) 히트맵 레이어
  const heat = new naver.maps.visualization.HeatMap({
    map, radius: 30, opacity: 0.7, dissipating: true
  });

  // 3) Worker 프록시에서 실데이터 받아와서 히트맵 포인트 생성
  async function loadCity(code){
    const url = `https://api.koreaaimap.com/reco/v1/citydata?code=${encodeURIComponent(code)}`;
    const res = await fetch(url, { cache: 'no-store' });
    const j = await res.json();
    if(!res.ok) throw new Error(j?.error?.message || 'fetch failed');

    // 정규 응답(place/updatedAt/categories 구조)로 내려오므로 그대로 사용 가능
    // 좌표는 우선 '장소 중심점'을 사용하고, 가중치/흩뿌리기(jitter)로 히트맵 표현
    // (세부 그리드 좌표를 갖추면 이 부분만 교체)
    const center = guessCenter(j.place.name || j.place.code);
    if(center){
      map.setCenter(new naver.maps.LatLng(center[0], center[1]));
      map.setZoom(15);
    }

    const pop = pickPopulationScore(j.categories)   // 0~100 추정 혼잡/인구 점수
    const pts = jitter(center, pop);
    heat.setData(pts);

    document.getElementById('updated').textContent =
      new Date(j.updatedAt).toLocaleTimeString('ko-KR',{hour:'2-digit',minute:'2-digit'}) + ' 기준';
  }

  // 임시: 코드/이름→중심좌표(필요 시 120개 표로 확장)
  function guessCenter(nameOrCode){
    const table = {
      'POI104':'37.5483,127.0792', '어린이대공원':'37.5483,127.0792',
      'POI072':'37.5261,126.9315', '여의도':'37.5261,126.9315',
      'POI014':'37.4981,127.0276', '강남역':'37.4981,127.0276'
    };
    const s = table[nameOrCode]; if(!s) return [37.5665,126.9780];
    const [lat,lng] = s.split(',').map(Number); return [lat,lng];
  }

  // 응답에서 인구/혼잡 관련 점수 대략 추출(스키마는 Worker에서 categories에 원본을 담아줌)
  function pickPopulationScore(categories){
    // 실제 필드명은 매뉴얼에 따라 바뀔 수 있음 → 없으면 60 고정 (시연용)
    // (Worker는 upstream RESULT 체크 후 normalizing해서 내려줌) :contentReference[oaicite:1]{index=1}
    const c = JSON.stringify(categories).toLowerCase();
    const m = c.match(/(congestion|ppltn|population).{0,20}?(\d{1,3})/);
    return Math.max(20, Math.min(100, m ? Number(m[2]) : 60));
  }

  // 중심 주위에 점수를 가중치로 흩뿌려 HeatMap 입력 생성
  function jitter(center, score){
    const [lat,lng] = center || [37.5665,126.9780];
    const n = Math.round(30 + score * 0.7);
    const r = 0.004 + score*0.00002; // 반경
    const pts = [];
    for(let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2, d = Math.random()*r;
      const p = new naver.maps.LatLng(lat + Math.cos(a)*d, lng + Math.sin(a)*d);
      pts.push({ location: p, weight: 1 + score/25 });
    }
    return pts;
  }

  document.getElementById('load').onclick = () => loadCity(document.getElementById('code').value);
  loadCity('POI104'); // 최초 로드
  </script>
</body>
</html>
